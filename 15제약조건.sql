--제약조건 - 컬럼에 원치않는 데이터가 입력, 삭제, 수정되는 것을 방지하기 위한 조건
-- PRIMARY KEY - 테이블의 고유 키, 중복 X, NULL X, PK는 테이블에 1개
-- UNIQUE - 중복 X , NULL O, 고유한 녀석
-- NOT NULL - NULL을 허용하지 않음.
-- FOREIGN KEY - 참조하는 테이블의 PK를 넣어놓은 컬럼, 중복 O, NULL O
-- CHECK - 컬럼에 대한 데이터 제한(WHERE절과 유사)

-- 제약조건을 확인하는 명령문 OR 마우스로 확인
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';

--1ST (열레벨)
DROP TABLE DEPTS;
CREATE TABLE DEPTS (
    DEPT_NO NUMBER(2)       CONSTRAINT DEPTS_DEPT_NO_PK PRIMARY KEY,
    DEPT_NAME VARCHAR2(30)  CONSTRAINT DEPTS_DEPT_NAME_NN NOT NULL,
    DEPT_DATE DATE          DEFAULT SYSDATE, --값이 들어가지 않을 때 자동으로 지정되는 기본값
    DEPT_PHONE VARCHAR2(30) CONSTRAINT DEPTS_DEPT_PHONE_UK UNIQUE,
    DEPT_GENDER CHAR(1)     CONSTRAINT DEPTS_DEPT_GENDER_CHECK CHECK (DEPT_GENDER IN ('F','M')),
    LOCA_ID NUMBER(4)       CONSTRAINT DEPTS_LOCA_ID_FK REFERENCES LOCATIONS (LOCATION_ID)
);
-- (CONSTRAINT는 생략가능) - 이름이 자동생성
DROP TABLE DEPTS;
CREATE TABLE DEPTS (
    DEPT_NO NUMBER(2)       PRIMARY KEY,
    DEPT_NAME VARCHAR2(30)  NOT NULL,
    DEPT_DATE DATE          DEFAULT SYSDATE, --값이 들어가지 않을 때 자동으로 지정되는 기본값
    DEPT_PHONE VARCHAR2(30) UNIQUE,
    DEPT_GENDER CHAR(1)     CHECK (DEPT_GENDER IN ('F','M')),
    LOCA_ID NUMBER(4)       REFERENCES LOCATIONS (LOCATION_ID)
);
DESC DEPTS;
INSERT INTO DEPTS(DEPT_NO, DEPT_NAME, DEPT_PHONE, DEPT_GENDER, LOCA_ID)
VALUES (1, NULL, '010....', 'F',1700); -- NOT NULL 제약 위배
INSERT INTO DEPTS (DEPT_NO, DEPT_NAME, DEPT_PHONE, DEPT_GENDER, LOCA_ID)
VALUES (1, 'HONG', '010....', 'X',1700); -- CHECK 제약 위배
INSERT INTO DEPTS (DEPT_NO, DEPT_NAME, DEPT_PHONE, DEPT_GENDER, LOCA_ID)
VALUES (1, 'HONG', '010....', 'F',100); -- FK 제약 위배
INSERT INTO DEPTS (DEPT_NO, DEPT_NAME, DEPT_PHONE, DEPT_GENDER, LOCA_ID)
VALUES (1, 'HONG', '010....', 'F',1700);
INSERT INTO DEPTS (DEPT_NO, DEPT_NAME, DEPT_PHONE, DEPT_GENDER, LOCA_ID)
VALUES (2, 'HONG', '010....', 'F',1700); -- UNIQUE 제약 위배
-- 개체 무결성 : 기본키에 NOT NULL일 수 없고, 중복될 수 없다. 규칙.
-- 참조 무결성 : 참조하는 테이블의 PK만 FK컬럼에 들어갈 수 있다. 규칙.
-- 도메인 무결성 : CHECK, UNIQUE 제약 안에서만 데이터가 들어갈 수 있다. 규칙.
--------------------------------------------------------------------------------
-- 2025.02.13 --
--2ND - 테이블 레벨 제약조건
DROP TABLE DEPTS;

CREATE TABLE DEPTS(
    DEPT_NO NUMBER(2),
    DEPT_NAME VARCHAR2(30)  NOT NULL,
    DEPT_DATE DATE          DEFAULT SYSDATE,
    DEPT_PHONE VARCHAR2(30),
    DEPT_GENDER CHAR(1),
    LOCA_ID NUMBER(4),
    CONSTRAINT DEPTS_DEPT_NO_PK PRIMARY KEY (DEPT_NO), --슈퍼키 지정은 테이블레벨로 가능함
    CONSTRAINT DEPTS_DEPT_PHONE_UK UNIQUE (DEPT_PHONE),
    CONSTRAINT DEPTS_DEPT_GENDER_CK CHECK (DEPT_GENDER IN ('F','M')),
    CONSTRAINT DEPTS_LOCA_ID_FK FOREIGN KEY (LOCA_ID) REFERENCES LOCATIONS(LOCATION_ID)
);
--3ND (제약조건의 추가 삭제), 수정은 없음
CREATE TABLE DEPTS(
    DEPT_NO NUMBER(2),
    DEPT_NAME VARCHAR2(30),
    DEPT_DATE DATE          DEFAULT SYSDATE,
    DEPT_PHONE VARCHAR2(30),
    DEPT_GENDER CHAR(1),
    LOCA_ID NUMBER(4)
);
ALTER TABLE DEPTS ADD CONSTRAINT DEPT_NO_PK PRIMARY KEY (DEPT_NO); --PK추가
ALTER TABLE DEPTS MODIFY DEPT_NAME VARCHAR(30) NOT NULL;--NOT NULL은 MODIFY구문으로 열 변경으로 추가함
ALTER TABLE DEPTS ADD CONSTRAINT DEPT_PHONE_UK UNIQUE (DEPT_PHONE); --UK추가
ALTER TABLE DEPTS ADD CONSTRAINT DEPT_GENDER_CK CHECK (DEPT_GENDER IN ('F','M')); --CK추가
ALTER TABLE DEPTS ADD CONSTRAINT LOCA_ID_FK FOREIGN KEY (LOCA_ID) REFERENCES LOCATIONS(LOCATION_ID); --FK추가

--제약조건의 삭제
ALTER TABLE DEPTS DROP PRIMARY KEY; -- 이렇게 지울 수 있음
ALTER TABLE DEPTS DROP CONSTRAINT LOCA_ID_FK; -- 이름으로도 지울 수 있음
--테이블의 제약조건을 SQL문으로 확인
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'DEPTS';
--------------------------------------------------------------------------------
--문제1.
--다음과 같은 테이블을 생성하고 데이터를 insert해보세요.
--테이블 제약조건은 아래와 같습니다. 
--조건) M_NAME 는 가변문자형 20byte, 널값을 허용하지 않음
--조건) M_NUM 은 숫자형 5자리, PRIMARY KEY 이름(mem_memnum_pk) 
--조건) REG_DATE 는 날짜형, 널값을 허용하지 않음, UNIQUE KEY 이름:(mem_regdate_uk)
--조건) GENDER 고정문자형 1byte, CHECK제약 (M, F)
--조건) LOCA 숫자형 4자리, FOREIGN KEY – 참조 locations테이블(location_id) 이름:(mem_loca_loc_locid_fk)
--| M_NAME | M_NUM | REG_DATE | SALARY | LOCA |
--| --- | --- | --- | --- | --- |
--| AAA | 1 | 2018-07-01 | 5000 | 1800 |
--| BBB | 2 | 2018-07-02 | 3000 | 1900 |
--| CCC | 3 | 2018-07-03 | 3000 | 2000 |
--| DDD | 4 | 오늘날짜 | 2000 | 2000 |

DROP TABLE MEMBER_TBL;
CREATE TABLE MEMBER_TBL (
    M_NAME VARCHAR2(20) NOT NULL,
    M_NUM NUMBER(5),
    REG_DATE DATE NOT NULL,
    SALARY NUMBER(10),
    LOCA NUMBER(4),
    CONSTRAINT MEM_MEMNUM_PK PRIMARY KEY (M_NUM),
    CONSTRAINT MEM_REGDATE_UL UNIQUE (REG_DATE),
    CONSTRAINT SALARY_CK CHECK (SALARY > 0),
    CONSTRAINT MEM_LOCA_LOC_LOCID_FK FOREIGN KEY (LOCA) REFERENCES LOCATIONS (LOCATION_ID)
);
DESC MEMBER_TBL;

INSERT INTO MEMBER_TBL VALUES('AAA',1,'2018-07-01',5000,1800);
INSERT INTO MEMBER_TBL VALUES('BBB',2,'2018-07-02',3000,1900);
INSERT INTO MEMBER_TBL VALUES('CCC',3,'2018-07-03',3000,2000);
INSERT INTO MEMBER_TBL VALUES('DDD',4,SYSDATE,2000,2000);

SELECT * FROM MEMBER_TBL;
--문제2.
--도서테이블, 도서 대여 이력 테이블을 생성하려 합니다.
--도서 테이블은
--도서번호(문자) PK, 도서명(문자), 출판사(문자), 입고일(날짜)
--도서 대여 이력 테이블은
--대여번호(숫자) PK, 도서번호(문자) FK, 대여일(날짜), 반납일(날짜), 반납여부(Y/N)
--를 가집니다.
--적절한 테이블을 생성해 보세요.
DROP TABLE LIBRARY_TBL;
DROP TABLE BOOKSTORE_TBL;

CREATE TABLE LIBRARY_TBL(
    B_NUM VARCHAR2(30),
    B_NAME VARCHAR2 (30),
    P_COMP VARCHAR2 (30),
    B_DATE DATE,
    CONSTRAINT B_NUM_PK PRIMARY KEY (B_NUM)
);
CREATE TABLE BOOKSTORE_TBL(
    N_BOOK NUMBER(5),
    B_NUM VARCHAR2(30),
    START_DATE DATE NOT NULL,
    END_DATE DATE NOT NULL,
    SE_BOOK CHAR(1),
    CONSTRAINT N_BOOK_PK PRIMARY KEY (N_BOOK),
    CONSTRAINT B_NUM_FK FOREIGN KEY (B_NUM) REFERENCES LIBRARY_TBL (B_NUM),
    CONSTRAINT SE_BOOK_CK CHECK (SE_BOOK IN ('Y','N'))
);


SELECT * FROM LIBRARY_TBL;
SELECT * FROM BOOKSTORE_TBL;