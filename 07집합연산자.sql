-- 집합연산자
-- UNION - 합집합(중복X)
-- UNION ALL - 합집합 (중복O)
-- INTERSECT - 교집합
-- MINUS - 차집합

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%';
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

-- 컬럼 개수가 일치해야 집합연산자 사용이 가능합니다 > UNION
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

-- 컬럼 개수가 일치하지 않아도 집합연산자 사용이 가능합니다 > UNION ALL
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION ALL
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

-- 위, 아래 조회문에서 중복되는 컬럼 값을 가져옴?
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
INTERSECT
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

-- 중복되는 컬럼 값을 그냥 빼버림
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
MINUS
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
--------------
-- 가상테이블을 합쳐서 사용할 수도 있다.
SELECT 'PARK', 200 FROM DUAL
UNION ALL
SELECT 'KIM', 300 FROM DUAL
UNION ALL
SELECT 'CHOI', 400 FROM DUAL;


----------------------------------------------------------
--시험의 단골문제
-- 분석함수
SELECT FIRST_NAME, SALARY, 
    RANK() OVER(ORDER BY SALARY DESC)AS 중복등수,
    DENSE_RANK() OVER(ORDER BY SALARY DESC) AS 중복없는등수,
    ROW_NUMBER() OVER(ORDER BY SALARY DESC) AS 일련번호,
    ROWNUM AS ROW_NUM -- 정렬이 되면 순서가 바뀜
FROM EMPLOYEES;